from playwright.sync_api import sync_playwright


def fetch_all_imdb_reviews(url: str):
    """
    Fetches all reviews for a particular movie from IMDb.

    :param url: The IMDb user reviews URL (e.g., 'https://www.imdb.com/title/tt31434030/reviews/')

    The following function logic for IMDb scraping was generated by Gemini 3 Flash.
    Reference: Google. (n.d.). Gemini 3 Flash [Large language model]. https://gemini.google.com/

    Performance Note:
    The execution takes approximately 1 minute per 200 reviews
    with a stable internet connection.
    """
    with sync_playwright() as p:
        browser = p.chromium.launch(headless=False)
        page = browser.new_page()

        print("Opening IMDb...")
        page.goto(url)

        # --- STEP 1 & 2: Click 'See all' and Scroll (Your original logic) ---
        while True:
            see_all_button = page.get_by_role("button", name="See all")
            if see_all_button.is_visible():
                print("\n'See all' button found. Clicking...")
                see_all_button.click()
                page.wait_for_timeout(2000)

            print("Scrolling to load reviews...")
            last_height = page.evaluate("document.body.scrollHeight")
            while True:
                page.evaluate("window.scrollTo(0, document.body.scrollHeight)")
                page.wait_for_timeout(2000)
                new_height = page.evaluate("document.body.scrollHeight")

                if new_height == last_height:
                    page.wait_for_timeout(2000)
                    if page.evaluate("document.body.scrollHeight") == new_height:
                        break
                last_height = new_height
                print(f"Loading more content...", end="\r")

            if not see_all_button.is_visible():
                break

        # --- STEP 3: Reveal Spoilers ---
        print("\nExpansion complete. Now revealing spoiler reviews...")

        # This finds the "Spoiler" labels specifically.
        # They usually have a class like 'ipc-expander' or 'ipc-accordion__item__title'
        # Using a text-based locator is safest:
        spoilers = page.get_by_text("Spoiler", exact=True)

        # We find how many there are and click each one
        spoiler_count = spoilers.count()
        print(f"Found {spoiler_count} hidden spoiler reviews. Expanding...")

        for i in range(spoiler_count):
            try:
                # Scroll the button into view before clicking (prevents errors)
                # spoilers.nth(i).scroll_into_view_if_needed()

                # Click the i-th spoiler button
                spoilers.nth(i).click()

                # A short, variable-like sleep (100ms to 300ms)
                # helps the browser process the DOM change without crashing
                # page.wait_for_timeout(100)
            except Exception:
                # Some might be off-screen or already expanded, we skip errors
                pass

        # --- STEP 4: Final Extraction (On-the-go memory saving) ---
        selector = "div.ipc-html-content-inner-div"
        review_elements = page.query_selector_all(selector)

        # Using a set to ensure no duplicates and save memory
        unique_reviews = {el.inner_text().strip() for el in review_elements}
        reviews_list = list(unique_reviews)

        print(f"\nSuccessfully scraped {len(reviews_list)} unique reviews (including spoilers)!")

        browser.close()
        return reviews_list
